"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _construct = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/reflect/construct"));

var _now = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/date/now"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _webexCore = require("@webex/webex-core");

var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));

var _peerConnectionManager = _interopRequireDefault(require("../peer-connection-manager"));

var _util = _interopRequireDefault(require("../media/util"));

var _constants = require("../constants");

var _request = _interopRequireDefault(require("./request"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = (0, _construct.default)(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_construct.default) return false; if (_construct.default.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call((0, _construct.default)(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class Reachability
 * @export
 */
var Reachability = /*#__PURE__*/function (_StatelessWebexPlugin) {
  (0, _inherits2.default)(Reachability, _StatelessWebexPlugin);

  var _super = _createSuper(Reachability);

  function Reachability(attrs, options) {
    var _this;

    (0, _classCallCheck2.default)(this, Reachability);
    _this = _super.call(this, {}, options);
    /**
     * internal request object for the server
     * @instance
     * @type {Array}
     * @private
     * @memberof Reachability
     */

    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "namespace", _constants.MEETINGS);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "setup", function () {
      _this.processedClusterResults = [];
      _this.peerConnectionMap = {};
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "gatherReachability", function () {
      _this.setup(); // Reset reachability result to empty to ensure no stale data


      try {
        window.localStorage.setItem(_constants.REACHABILITY.localStorage, (0, _stringify.default)({})); // Get clusters from Orpheus

        return _this.reachabilityRequest.getClusters().then(function (clusters) {
          return (// Perform Reachability Check
            _this.performReachabilityCheck(clusters).then(function (response) {
              window.localStorage.setItem(_constants.REACHABILITY.localStorage, (0, _stringify.default)(response));
              return response;
            })
          );
        }).catch(function (error) {
          _loggerProxy.default.logger.error("Reachability:index#gatherReachability --> Error in calling getClusters(): ".concat(error));

          return {};
        });
      } catch (error) {
        _loggerProxy.default.logger.error("Reachability:index#gatherReachability --> Error in accessing LocalStorage: ".concat(error));

        return {};
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "performReachabilityCheck", function (clusterList) {
      if (!clusterList || !clusterList.length) {
        return _promise.default.resolve({});
      }

      var localSDPList = [];
      return new _promise.default(function (resolve) {
        _this.getLocalSDPForClusters(clusterList).then(function (localSDPData) {
          if (!localSDPData || !(0, _keys.default)(localSDPData).length || !localSDPData.localSDPList || !localSDPData.peerConnection) {
            // TODO: handle the error condition properly and try retry
            _loggerProxy.default.logger.info('Reachability:index#performReachabilityCheck --> Local SDP is empty or has missing elements..returning');

            resolve({});
          }

          _this.peerConnectionMap = localSDPData.peerConnection;
          localSDPList = localSDPData.localSDPList;

          _this.setRemoteOfferForEachCluster(localSDPList).then(function (response) {
            resolve(response);
          });
        }).catch(function (error) {
          _loggerProxy.default.logger.error("Reachability:index#performReachabilityCheck --> Error in getLocalSDPForClusters: ".concat(error));

          resolve({});
        });
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "setRemoteOfferForEachCluster", function (localSDPList) {
      var iceResult = {};
      return new _promise.default(function (resolve) {
        _this.reachabilityRequest.remoteSDPForClusters(localSDPList).then(function (remoteSDPResponse) {
          var remoteSDPList = remoteSDPResponse.answers;

          if (!remoteSDPList || !remoteSDPList.length) {
            _loggerProxy.default.logger.info('Reachability:index#setRemoteOfferForEachCluster --> Remote SDP is empty.');

            _this.cleanUpPeerConnections(_this.peerConnectionMap);

            resolve({});
          }

          remoteSDPList.forEach(function (remoteSdp) {
            var jsonObj = remoteSdp;
            var clusterId = jsonObj.clusterId;

            if (jsonObj && jsonObj.sdp) {
              var pc = _this.peerConnectionMap[clusterId];

              _this.setIceCallBackHandlers(pc).then(function (iceStatsResult) {
                iceStatsResult.clusterId = clusterId;

                _this.processedClusterResults.push(iceStatsResult.clusterId);

                iceResult[iceStatsResult.clusterId] = {
                  start: iceStatsResult.iceStats.start,
                  stop: iceStatsResult.iceStats.stop
                };

                if (_this.processedClusterResults.length === remoteSDPList.length) {
                  var reachabilityResult = _this.parseIceResultToReachabilityResult(iceResult);

                  _loggerProxy.default.logger.info("Reachability:index#setRemoteOfferForEachCluster --> Returning reachability result".concat((0, _stringify.default)(reachabilityResult)));

                  resolve(reachabilityResult);
                }
              }).catch(function (error) {
                _loggerProxy.default.logger.error("Reachability:index#setRemoteOfferForEachCluster --> Error in setIceCallBackHandlers(): ".concat(error));

                _this.cleanUpPeerConnections(_this.peerConnectionMap);

                resolve({});
              });

              _peerConnectionManager.default.setRemoteSessionDetails(pc, _constants.ANSWER, jsonObj.sdp);
            } else {
              _loggerProxy.default.logger.error('Reachability:index#setRemoteOfferForEachCluster --> Error in getting remote sdp.');

              _this.processedClusterResults.push(clusterId);

              if (_this.processedClusterResults.length === remoteSDPList.length) {
                _this.cleanUpPeerConnections(_this.peerConnectionMap);

                resolve({});
              }
            }
          });
        }).catch(function (error) {
          _loggerProxy.default.logger.error("Reachability:index#setRemoteOfferForEachCluster --> Error in remoteSDPForClusters!:".concat(error));

          _this.cleanUpPeerConnections(_this.peerConnectionMap);

          resolve({});
        });
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getLocalSDPForClusters", function (clusterList) {
      var localSDPData = {};
      var localSDPList = [];
      var peerConnectionMap = {};
      return new _promise.default(function (resolve, reject) {
        clusterList.forEach(function (cluster) {
          var clusterId = cluster;

          _peerConnectionManager.default.createOffer(_util.default.createPeerConnection()).then(function (peerConnection) {
            peerConnectionMap[clusterId] = peerConnection;
            var localSDP = {
              sdp: peerConnection.sdp,
              clusterId: clusterId
            };
            localSDPList.push(localSDP);

            if (localSDPList.length === clusterList.length) {
              localSDPData.peerConnection = peerConnectionMap;
              localSDPData.localSDPList = localSDPList;
              resolve(localSDPData);
            }
          }).catch(function (error) {
            _loggerProxy.default.logger.error("Reachability:index#getLocalSDPForClusters --> Error in getLocalSDP : ".concat(error));

            reject(error);
          });
        });
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "parseIceResultToReachabilityResult", function (iceResult) {
      if (!iceResult || !(0, _keys.default)(iceResult).length) {
        return {};
      }

      var result = {};

      for (var _i = 0, _Object$keys2 = (0, _keys.default)(iceResult); _i < _Object$keys2.length; _i++) {
        var clusterId = _Object$keys2[_i];
        var reachability = {};

        if (iceResult[clusterId].start > 0 && iceResult[clusterId].stop > 0) {
          var latency = iceResult[clusterId].stop - iceResult[clusterId].start;
          reachability = {
            reachable: true,
            latencyInMilliseconds: latency
          };
        } else {
          reachability = {
            reachable: false
          };
        }

        result[clusterId] = {
          udp: reachability
        };
      }

      return result;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "cleanUpPeerConnections", function (peerConnectionMap) {
      for (var _i2 = 0, _Object$keys3 = (0, _keys.default)(peerConnectionMap); _i2 < _Object$keys3.length; _i2++) {
        var key = _Object$keys3[_i2];
        var pc = peerConnectionMap[key];

        if (pc) {
          _loggerProxy.default.logger.info("Reachability:index#cleanUpPeerConnections --> Cleaning up peer connection created for cluster : ".concat(key));

          pc.close();
        }
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "setIceCallBackHandlers", function (pc) {
      var timeout = null;
      var iceStats = {
        start: 0,
        stop: 0
      };
      return new _promise.default(function (resolve) {
        function iceComplete(isSuccessful, timeout, iceStats) {
          if (isSuccessful) {
            if (timeout) {
              window.clearTimeout(timeout);
              timeout = undefined;
            }
          }

          pc.close();
          resolve({
            iceStats: iceStats
          });
        }

        timeout = window.setTimeout(function () {
          _loggerProxy.default.logger.warn("Reachability:index#setIceCallBackHandlers --> iceCallBackHandler#".concat(_this.clusterId, " ice handler timed out."));

          iceComplete(false, timeout, iceStats);
        }, 5000);

        pc.oniceconnectionstatechange = function () {
          if (pc) {
            if (pc.iceConnectionState === _constants.ICE_STATE.CHECKING) {
              iceStats.start = (0, _now.default)();
            }

            if (pc.iceConnectionState === _constants.ICE_STATE.CONNECTED) {
              iceStats.stop = (0, _now.default)();
              iceComplete(true, timeout, iceStats);
            }

            if (pc.iceConnectionState === _constants.ICE_STATE.FAILED) {
              iceComplete(false, timeout, iceStats);
            }
          }
        };
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getClusters", function () {
      return _this.reachabilityRequest.getClusters();
    });
    _this.reachabilityRequest = new _request.default({}, options);
    return _this;
  }
  /**
   * utility function
   * @returns {undefined}
   * @private
   * @memberof Reachability
   */


  return Reachability;
}(_webexCore.StatelessWebexPlugin);

exports.default = Reachability;
//# sourceMappingURL=index.js.map
