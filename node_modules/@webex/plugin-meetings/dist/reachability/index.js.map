{"version":3,"sources":["index.js"],"names":["Reachability","attrs","options","MEETINGS","processedClusterResults","peerConnectionMap","setup","window","localStorage","setItem","REACHABILITY","reachabilityRequest","getClusters","then","clusters","performReachabilityCheck","response","catch","error","LoggerProxy","logger","clusterList","length","resolve","localSDPList","getLocalSDPForClusters","localSDPData","peerConnection","info","setRemoteOfferForEachCluster","iceResult","remoteSDPForClusters","remoteSDPResponse","remoteSDPList","answers","cleanUpPeerConnections","forEach","remoteSdp","jsonObj","clusterId","sdp","pc","setIceCallBackHandlers","iceStatsResult","push","start","iceStats","stop","reachabilityResult","parseIceResultToReachabilityResult","peerConnectionManager","setRemoteSessionDetails","ANSWER","reject","cluster","createOffer","MediaUtil","createPeerConnection","localSDP","result","reachability","latency","reachable","latencyInMilliseconds","udp","key","close","timeout","iceComplete","isSuccessful","clearTimeout","undefined","setTimeout","warn","oniceconnectionstatechange","iceConnectionState","ICE_STATE","CHECKING","CONNECTED","FAILED","ReachabilityRequest","StatelessWebexPlugin"],"mappings":"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","sourcesContent":["\n/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\n/* globals window */\nimport {StatelessWebexPlugin} from '@webex/webex-core';\n\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport peerConnectionManager from '../peer-connection-manager';\nimport MediaUtil from '../media/util';\nimport {ICE_STATE, MEETINGS, REACHABILITY, ANSWER} from '../constants';\n\nimport ReachabilityRequest from './request';\n\n/**\n * @class Reachability\n * @export\n */\nexport default class Reachability extends StatelessWebexPlugin {\n  namespace = MEETINGS;\n\n  constructor(attrs, options) {\n    super({}, options);\n    /**\n     * internal request object for the server\n     * @instance\n     * @type {Array}\n     * @private\n     * @memberof Reachability\n     */\n    this.reachabilityRequest = new ReachabilityRequest({}, options);\n  }\n\n  /**\n   * utility function\n   * @returns {undefined}\n   * @private\n   * @memberof Reachability\n   */\n  setup = () => {\n    this.processedClusterResults = [];\n    this.peerConnectionMap = {};\n  }\n\n  /**\n   * fetches reachability data\n   * @returns {Object} reachability data\n   * @public\n   * @memberof Reachability\n   */\n  gatherReachability = () => {\n    this.setup();\n    // Reset reachability result to empty to ensure no stale data\n    try {\n      window.localStorage.setItem(REACHABILITY.localStorage, JSON.stringify({}));\n\n      // Get clusters from Orpheus\n      return this.reachabilityRequest.getClusters()\n        .then((clusters) =>\n          // Perform Reachability Check\n          this.performReachabilityCheck(clusters)\n            .then((response) => {\n              window.localStorage.setItem(REACHABILITY.localStorage, JSON.stringify(response));\n\n              return response;\n            }))\n        .catch((error) => {\n          LoggerProxy.logger.error(`Reachability:index#gatherReachability --> Error in calling getClusters(): ${error}`);\n\n          return {};\n        });\n    }\n    catch (error) {\n      LoggerProxy.logger.error(`Reachability:index#gatherReachability --> Error in accessing LocalStorage: ${error}`);\n\n      return {};\n    }\n  };\n\n  /**\n   * fetches reachability data\n   * @param {object} clusterList\n   * @returns {object} reachability check results\n   * @private\n   * @memberof Reachability\n   */\n  performReachabilityCheck = (clusterList) => {\n    if (!clusterList || !clusterList.length) {\n      return Promise.resolve({});\n    }\n\n    let localSDPList = [];\n\n    return new Promise(((resolve) => {\n      this.getLocalSDPForClusters(clusterList)\n        .then((localSDPData) => {\n          if (!localSDPData || !Object.keys(localSDPData).length || !localSDPData.localSDPList || !localSDPData.peerConnection) {\n            // TODO: handle the error condition properly and try retry\n            LoggerProxy.logger.info('Reachability:index#performReachabilityCheck --> Local SDP is empty or has missing elements..returning');\n            resolve({});\n          }\n\n          this.peerConnectionMap = localSDPData.peerConnection;\n          ({localSDPList} = localSDPData);\n          this.setRemoteOfferForEachCluster(localSDPList)\n            .then((response) => {\n              resolve(response);\n            });\n        })\n        .catch((error) => {\n          LoggerProxy.logger.error(`Reachability:index#performReachabilityCheck --> Error in getLocalSDPForClusters: ${error}`);\n          resolve({});\n        });\n    }));\n  };\n\n  /**\n   * sets remote offer for each clusters\n   * @param {object} localSDPList local SDP generated\n   * @returns {object} reachability check results\n   * @private\n   * @memberof Reachability\n   */\n  setRemoteOfferForEachCluster = (localSDPList) => {\n    const iceResult = {};\n\n    return new Promise((resolve) => {\n      this.reachabilityRequest.remoteSDPForClusters(localSDPList)\n        .then((remoteSDPResponse) => {\n          const remoteSDPList = remoteSDPResponse.answers;\n\n          if (!remoteSDPList || !remoteSDPList.length) {\n            LoggerProxy.logger.info('Reachability:index#setRemoteOfferForEachCluster --> Remote SDP is empty.');\n            this.cleanUpPeerConnections(this.peerConnectionMap);\n            resolve({});\n          }\n          remoteSDPList.forEach((remoteSdp) => {\n            const jsonObj = remoteSdp;\n            const {clusterId} = jsonObj;\n\n            if (jsonObj && jsonObj.sdp) {\n              const pc = this.peerConnectionMap[clusterId];\n\n              this.setIceCallBackHandlers(pc)\n                .then((iceStatsResult) => {\n                  iceStatsResult.clusterId = clusterId;\n                  this.processedClusterResults.push(iceStatsResult.clusterId);\n                  iceResult[iceStatsResult.clusterId] = {\n                    start: iceStatsResult.iceStats.start,\n                    stop: iceStatsResult.iceStats.stop\n                  };\n                  if (this.processedClusterResults.length === remoteSDPList.length) {\n                    const reachabilityResult = this.parseIceResultToReachabilityResult(iceResult);\n\n                    LoggerProxy.logger.info(`Reachability:index#setRemoteOfferForEachCluster --> Returning reachability result${JSON.stringify(reachabilityResult)}`);\n                    resolve(reachabilityResult);\n                  }\n                })\n                .catch((error) => {\n                  LoggerProxy.logger.error(`Reachability:index#setRemoteOfferForEachCluster --> Error in setIceCallBackHandlers(): ${error}`);\n                  this.cleanUpPeerConnections(this.peerConnectionMap);\n                  resolve({});\n                });\n              peerConnectionManager.setRemoteSessionDetails(pc, ANSWER, jsonObj.sdp);\n            }\n            else {\n              LoggerProxy.logger.error('Reachability:index#setRemoteOfferForEachCluster --> Error in getting remote sdp.');\n              this.processedClusterResults.push(clusterId);\n              if (this.processedClusterResults.length === remoteSDPList.length) {\n                this.cleanUpPeerConnections(this.peerConnectionMap);\n                resolve({});\n              }\n            }\n          });\n        })\n        .catch((error) => {\n          LoggerProxy.logger.error(`Reachability:index#setRemoteOfferForEachCluster --> Error in remoteSDPForClusters!:${error}`);\n          this.cleanUpPeerConnections(this.peerConnectionMap);\n          resolve({});\n        });\n    });\n  }\n\n  /**\n   * creates offer and generates localSDP\n   * @param {object} clusterList cluster List\n   * @returns {object} localSDPData\n   * @private\n   * @memberof Reachability\n   */\n  getLocalSDPForClusters = (clusterList) => {\n    const localSDPData = {};\n    const localSDPList = [];\n    const peerConnectionMap = {};\n\n    return new Promise(((resolve, reject) => {\n      clusterList.forEach((cluster) => {\n        const clusterId = cluster;\n\n        peerConnectionManager.createOffer(MediaUtil.createPeerConnection())\n          .then((peerConnection) => {\n            peerConnectionMap[clusterId] = peerConnection;\n\n            const localSDP = {\n              sdp: peerConnection.sdp,\n              clusterId\n            };\n\n            localSDPList.push(localSDP);\n\n            if (localSDPList.length === clusterList.length) {\n              localSDPData.peerConnection = peerConnectionMap;\n              localSDPData.localSDPList = localSDPList;\n              resolve(localSDPData);\n            }\n          })\n          .catch((error) => {\n            LoggerProxy.logger.error(`Reachability:index#getLocalSDPForClusters --> Error in getLocalSDP : ${error}`);\n            reject(error);\n          });\n      });\n    }));\n  };\n\n  /**\n   * Calculates time to establish connection\n   * @param {object} iceResult iceResults\n   * @returns {object} result\n   * @private\n   * @memberof Reachability\n   */\n  parseIceResultToReachabilityResult = (iceResult) => {\n    if (!iceResult || !Object.keys(iceResult).length) {\n      return {};\n    }\n    const result = {};\n\n    for (const clusterId of Object.keys(iceResult)) {\n      let reachability = {};\n\n      if (iceResult[clusterId].start > 0 && iceResult[clusterId].stop > 0) {\n        const latency = iceResult[clusterId].stop - iceResult[clusterId].start;\n\n        reachability = {\n          reachable: true,\n          latencyInMilliseconds: latency\n        };\n      }\n      else {\n        reachability = {reachable: false};\n      }\n      result[clusterId] = {udp: reachability};\n    }\n\n    return result;\n  };\n\n  /**\n   * cleans all the peerconnection\n   * @param {object} peerConnectionMap peerconnectionList\n   * @returns {object} localSDPData\n   * @private\n   * @memberof Reachability\n   */\n  cleanUpPeerConnections = (peerConnectionMap) => {\n    for (const key of Object.keys(peerConnectionMap)) {\n      const pc = peerConnectionMap[key];\n\n      if (pc) {\n        LoggerProxy.logger.info(`Reachability:index#cleanUpPeerConnections --> Cleaning up peer connection created for cluster : ${key}`);\n        pc.close();\n      }\n    }\n  };\n\n  /**\n   * sets the success callback for peerconnection\n   * @param {object} pc peerconnection\n   * @returns {object} iceState\n   * @private\n   * @memberof Reachability\n   */\n  setIceCallBackHandlers = (pc) => {\n    let timeout = null;\n    const iceStats = {start: 0, stop: 0};\n\n    return new Promise(((resolve) => {\n      function iceComplete(isSuccessful, timeout, iceStats) {\n        if (isSuccessful) {\n          if (timeout) {\n            window.clearTimeout(timeout);\n            timeout = undefined;\n          }\n        }\n        pc.close();\n        resolve({iceStats});\n      }\n\n      timeout = window.setTimeout(() => {\n        LoggerProxy.logger.warn(`Reachability:index#setIceCallBackHandlers --> iceCallBackHandler#${this.clusterId} ice handler timed out.`);\n        iceComplete(false, timeout, iceStats);\n      }, 5000);\n\n      pc.oniceconnectionstatechange = () => {\n        if (pc) {\n          if (pc.iceConnectionState === ICE_STATE.CHECKING) {\n            iceStats.start = Date.now();\n          }\n          if (pc.iceConnectionState === ICE_STATE.CONNECTED) {\n            iceStats.stop = Date.now();\n            iceComplete(true, timeout, iceStats);\n          }\n          if (pc.iceConnectionState === ICE_STATE.FAILED) {\n            iceComplete(false, timeout, iceStats);\n          }\n        }\n      };\n    }));\n  };\n\n  /**\n   * proxy to the server request for clusters\n   * @returns {Promise}\n   * @private\n   * @memberof Reachability\n   */\n  getClusters = () => this.reachabilityRequest.getClusters()\n}\n"]}